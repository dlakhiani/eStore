/*
 * This Java source file was generated by the Gradle 'init' task.
 * Class for holding the Product Superclass ArrayList
 * @author Dhruv Lakhiani
 */
package eStoreSearch;

import java.util.Scanner;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.Set;
import java.util.Iterator;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.PrintWriter;
import java.io.FileNotFoundException;

public class EStoreSearch {
  public static final int SYEAR = 1000;
  public static final int EYEAR = 9999;
  protected ArrayList<Product> p;
  protected HashMap<String, ArrayList<Integer>> hash;

  /**
   * This constructor creates EStoreSearch product ArrayList and 
   * HashMap{@literal <}String, ArrayList{@literal <}Integer{@literal >}{@literal >} for efficient description searching.
   */
  public EStoreSearch() {
    p = new ArrayList<Product>();
    hash = new HashMap<String, ArrayList<Integer>>();
  }

  /**
   * This method adds a Product to the productList, either Book or Electronic
   * @param pList is Product ArrayList
   * @param p is the Product object.
   * @return ArrayList: the updated productList containing product passed.
   */
  public ArrayList<Product> addProduct(ArrayList<Product> pList, Product p) {
    pList.add(p);
    return pList;
  }

  /**
  * This method checks for a duplicate productID in 
  * Product ArrayList.
  * @param pList is Product ArrayList
  * @param id is the productID (int) given
  * @return boolean if duplicate is false/true.
  */
  public boolean compareID(ArrayList<Product> pList, int id) {
    boolean duplicate=false;
    for (Product p : pList) {
      if (id == p.getProductID()) {
        duplicate = true;
      }
    }
    return duplicate;
  }
  
  /**
  * This method checks for an empty String inputted by the user
  * @param storeSentence is the String
  * @return boolean: if the string is empty (true) else, false.
  */
  public boolean emptyString(String storeSentence) {
    if (storeSentence==null || storeSentence.length() == 0 ||
        storeSentence.trim().isEmpty() || storeSentence.equals("[\\s]")) {
      return true;
    } else {
      return false;
    }
  }
  
  /**
  * This method checks if the String length matches the length needed
  * for a particular input
  * @param storeSentence is the String
  * @param length is the numerical length (int)
  * @return boolean: if the string is empty (true) else, false.
  */
  public boolean isOfLength(int length, String storeSentence) {
    if (storeSentence.length()==length) {
      return true;
    } else {
      return false;
    }
  }
  
  /**
  * This method checks for a hyphen at the end of the String input
  * @param storeSentence is the String
  * @return boolean: if the string has a hyphen at end (true) else, false.
  */
  public boolean hyphenAtEnd(String storeSentence) {
    boolean itIs = true;
    if (storeSentence.charAt(0) == '-') {
      itIs = false;
    } else if (storeSentence.charAt(storeSentence.length()-1) == '-') {
      itIs = true;
    }
    return itIs;
  }
  
  /**
  * This method prints Product ArrayList.
  * @param pList is Product ArrayList
  * @return int: 1 if items have been printed, else 0.
  */
  public int printAllItems(ArrayList<Product> pList) {
    int works =0;
    for (Product p : pList) {
      System.out.println("\n"+p.toString());
      works=1;
    }
    return works;
  }
  
  /**
  * This method searches for the Products containing the
  * productID given, and prints the ones that have it.
  * @param pList is Product ArrayList
  * @param id is the productID (int) given.
  * @return int: 1 if items have been printed, else 0.
  */
  public int searchID(ArrayList<Product> pList, int id) {
    int works=0;
    for (int i=0;i<pList.size();i++) { 
      if (id == pList.get(i).getProductID()) {
        System.out.println(pList.get(i).toString());
        System.out.println();
        works = 1;
      }
    }

    if (works != 1) {
      System.out.println("There is no product with the given productID: "+id);
    } else {
      works = 1;
    }
    return works;
  }
  
  /**
  * This method searches for the Products containing the
  * description given, and prints the Products that have it.
  * @param pList is Product ArrayList
  * @param desc is the description (String) given.
  * @param hashDesc is the hashMap for the existing descriptions.
  * @return int: 1 if items have been printed, else 0.
  */
  public int searchDesc(ArrayList<Product> pList, String desc, HashMap<String, ArrayList<Integer>> hashDesc) {
    int works=0;
    //split keyword description
    ArrayList<Integer> intersection = new ArrayList<Integer>(); //final arrayList for description
    for (int i = 0; i < pList.size(); i++) { //pre-fill arrayList with indices of pList
      intersection.add(i);
    }
    
    Set<HashMap.Entry<String, ArrayList<Integer>>> entries = hashDesc.entrySet(); 
    Iterator<HashMap.Entry<String, ArrayList<Integer>>> iter = entries.iterator(); //used to move through hashMap
    desc = desc.replaceAll("\\s"," ").trim(); //remove extra white space from userKeyword
    String [] splittedDesc = desc.split("[^a-zA-Z0-9.]"); //split keywords into array
    for (int i = 0; i < splittedDesc.length; i++) { //loop hashMap through the keywords provided
      iter = entries.iterator();
      while (iter.hasNext()) {
        HashMap.Entry<String, ArrayList<Integer>> entry = iter.next();
        if (splittedDesc[i].equalsIgnoreCase(entry.getKey())) { //has key? store indices!
          intersection.retainAll(entry.getValue());            
        }
      }
    }

    for (int i = 0; i < intersection.size(); i++) {
      System.out.println("\n"+pList.get(intersection.get(i)));
      works=1;
    }

    if (works != 1) {
      System.out.println("\nThere is no product with the given description: "+desc);
    } else {
      works = 1;
    }
    return works;
  }
  
  /**
  * This method searches for the Products containing the
  * time period given, and prints the Products that have it.
  * @param pList is Product ArrayList
  * @param start is the beginning year (int).
  * @param end is the ending year (int).
  * @return int: 1 if items have been printed, else 0.
  */
  public int searchTime(ArrayList<Product> pList, int start, int end) {
    int works=0;
    for (int i=0;i<pList.size();i++) { 
      int pYear = Integer.parseInt(pList.get(i).getYear());
      if ((pYear >= start) && (pYear <= end)) {
        System.out.println(pList.get(i).toString());
        System.out.println();
        works = 1;
      }
    }
    if (works != 1) {
      System.out.println("There is no product within the given time period: "+start+" - "+end);
    } else {
      works = 1;
    }
    return works;
  }
  
  /**
  * This method searches for the Products containing the time period
  * and the description given, and prints the Products that have it.
  * @param pList is Product ArrayList
  * @param desc is the description given (String).
  * @param start is the beginning year (int).
  * @param end is the ending year (int).
  * @param hashDesc is the hashMap for the existing descriptions.
  * @return int: 1 if items have been printed, else 0.
  */
  public int searchDescAndTime(ArrayList<Product> pList, String desc, int start, int end, HashMap<String, ArrayList<Integer>> hashDesc) {
    int works = 0;
    //split keyword description
    ArrayList<Integer> intersection = new ArrayList<Integer>(); //final arrayList for description
    for (int i = 0; i < pList.size(); i++) { //pre-fill arrayList with indices of pList
      intersection.add(i);
    }
    
    Set<HashMap.Entry<String, ArrayList<Integer>>> entries = hashDesc.entrySet(); 
    Iterator<HashMap.Entry<String, ArrayList<Integer>>> iter = entries.iterator(); //used to move through hashMap
    desc = desc.replaceAll("\\s"," ").trim(); //remove extra white space from userKeyword
    String [] splittedDesc = desc.split("[^a-zA-Z0-9.]"); //split keywords into array
    for (int i = 0; i < splittedDesc.length; i++) { //loop hashMap through the keywords provided
      iter = entries.iterator();
      while (iter.hasNext()) {
        HashMap.Entry<String, ArrayList<Integer>> entry = iter.next();
        if (splittedDesc[i].equalsIgnoreCase(entry.getKey())) { //has key? sotre indices!
          intersection.retainAll(entry.getValue());            
        }
      }
    }

    for (int i = 0; i < intersection.size(); i++) {
      int pYear = Integer.parseInt(pList.get(i).getYear());
      if ( (pYear >= start) && (pYear <= end) ) {
        System.out.println("\n"+pList.get(intersection.get(i)));
        works=1;
      }
    }

    if (works != 1) {
      System.out.println("There is no product with the given description: "+desc+
                         " and time period: "+start+" - "+end);
    } else {
      works = 1;
    }
    return works;
  }
  
  /**
  * This method searches for the Products containing the time period
  * and the productID given, and prints the Products that have it.
  * @param pList is Product ArrayList
  * @param id is the productID (int) given.
  * @param start is the beginning year (int).
  * @param end is the ending year (int).
  * @return int: 1 if items have been printed, else 0.
  */
  public int searchIDAndTime(ArrayList<Product> pList, int id, int start, int end) {
    int works=0;
    for (int i=0;i<pList.size();i++) { 
      int pYear = Integer.parseInt(pList.get(i).getYear());
      if ((pYear >= start) && (pYear <= end)) {
        if (id == pList.get(i).getProductID()) {
          System.out.println(pList.get(i).toString());
          System.out.println();
          works = 1;
        }
      }
    }
    if (works != 1) {
      System.out.println("There is no product with the given productID: "+id+
                         " and time period: "+start+" - "+end);
    } else {
      works = 1;
    }
    return works;
  }
  
  /**
  * This method searches for the Products containing the productID
  * and the description given, and prints the Products that have it.
  * @param pList is Product ArrayList
  * @param id is the productID (int) given.
  * @param desc is the description (String) given.
  * @param hashDesc is the hashMap for the existing descriptions.
  * @return int: 1 if items have been printed, else 0.
  */
  public int searchIDAndDesc(ArrayList<Product> pList, int id, String desc, HashMap<String, ArrayList<Integer>> hashDesc) {
    int works = 0;
    //split keyword description
    ArrayList<Integer> intersection = new ArrayList<Integer>(); //final arrayList for description
    for (int i = 0; i < pList.size(); i++) { //pre-fill arrayList with indices of pList
      intersection.add(i);
    }
    
    Set<HashMap.Entry<String, ArrayList<Integer>>> entries = hashDesc.entrySet(); 
    Iterator<HashMap.Entry<String, ArrayList<Integer>>> iter = entries.iterator(); //used to move through hashMap
    desc = desc.replaceAll("\\s"," ").trim(); //remove extra white space from userKeyword
    String [] splittedDesc = desc.split("[^a-zA-Z0-9.]"); //split keywords into array
    for (int i = 0; i < splittedDesc.length; i++) { //loop hashMap through the keywords provided
      iter = entries.iterator();
      while (iter.hasNext()) {
        HashMap.Entry<String, ArrayList<Integer>> entry = iter.next();
        if (splittedDesc[i].equalsIgnoreCase(entry.getKey())) { //has key? sotre indices!
          intersection.retainAll(entry.getValue());            
        }
      }
    }

    for (int i = 0; i < intersection.size(); i++) {
      if (id == pList.get(i).getProductID()) {
        System.out.println("\n"+pList.get(intersection.get(i)));
        works=1;
      }
    }

    if (works != 1) {
      String formatID = String.format("%06d", id);
      System.out.println("There is no product with the given description: "+desc+
                         " and productID: "+ formatID);
    } else {
      works = 1;
    }
    return works;
  }
  
  /**
  * This method searches for the Products containing the productID, time period,
  * and the description given, and prints the Products that have it.
  * @param pList is Product ArrayList
  * @param id is the productID (int) given.
  * @param start is the beginning year (int).
  * @param end is the ending year (int).
  * @param desc is the description given (String).
  * @param hashDesc is the hashMap for the existing descriptions.
  * @return int: 1 if items have been printed, else 0.
  */
  public int searchSpecific(ArrayList<Product> pList, int id, String desc, int start, int end, HashMap<String, ArrayList<Integer>> hashDesc) {
    int works = 0;
    //split keyword description
    ArrayList<Integer> intersection = new ArrayList<Integer>(); //final arrayList for description
    for (int i = 0; i < pList.size(); i++) { //pre-fill arrayList with indices of pList
      intersection.add(i);
    }
    
    Set<HashMap.Entry<String, ArrayList<Integer>>> entries = hashDesc.entrySet(); 
    Iterator<HashMap.Entry<String, ArrayList<Integer>>> iter = entries.iterator(); //used to move through hashMap
    desc = desc.replaceAll("\\s"," ").trim(); //remove extra white space from userKeyword
    String [] splittedDesc = desc.split("[^a-zA-Z0-9.]"); //split keywords into array
    for (int i = 0; i < splittedDesc.length; i++) { //loop hashMap through the keywords provided
      iter = entries.iterator();
      while (iter.hasNext()) {
        HashMap.Entry<String, ArrayList<Integer>> entry = iter.next();
        if (splittedDesc[i].equalsIgnoreCase(entry.getKey())) { //has key? sotre indices!
          intersection.retainAll(entry.getValue());            
        }
      }
    }

    for (int i = 0; i < intersection.size(); i++) {
      int pYear = Integer.parseInt(pList.get(i).getYear());
      if ( (pYear >= start) && (pYear <= end) ) {
        if (id == pList.get(i).getProductID()) {
          System.out.println("\n"+pList.get(intersection.get(i)));
          works=1;
        }
      }
    }

    if (works != 1) {
      System.out.println("There is no product of productID: "+id+", with the given description: "+desc+
                         ", and time period: "+start+" - "+end);
    } else {
      works = 1;
    }
    return works;
  }

  /**
   * This method parses the input file into the productList for the program.
   * @param file provides all the attribute values for the productList of the program.
   * @return ArrayList: the productList that will be used for the program.
   */
  public ArrayList<Product> fileRead(String file) {
    Scanner inputStream = null;
    ArrayList<Product> temp = new ArrayList<Product>();
    try {
      inputStream = new Scanner(new FileInputStream(file));
    } catch (FileNotFoundException e) {
      System.out.println("File \""+ file +"\" was not found");
      System.out.println("or could not be opened.");
      System.exit(0);
    }
    
    if (inputStream.hasNextLine()==false) {
      System.out.println("File \""+ file +"\" is empty\n");
    } else {
      String [] splittedSen;
      String input="";
      String delimeters = " = ";
      while (inputStream.hasNextLine()) { //reading details 
        input = inputStream.nextLine();
        splittedSen = input.split(delimeters);

        if (splittedSen[0].equals("type")) {
          if (splittedSen[1].equals("\"book\"")) {
            String [] storeBook = new String[6];
            for (int i = 0; i < 6; i++) {
              input = inputStream.nextLine();
              splittedSen = input.split(delimeters);
              splittedSen[1] = splittedSen[1].replaceAll("\"","").trim();
              storeBook[i] = splittedSen[1];
            } 
            int inputID = Integer.parseInt(storeBook[0]);
            Float inputPrice =  Float.parseFloat(storeBook[2]);
            try {
              Book b = new Book( inputID, storeBook[1], inputPrice,
                storeBook[3], storeBook[4], storeBook[5]);
              temp.add(b);
            } catch (Exception e) {
              //handle exception
              System.out.println(e.getMessage());
            }
          } else {
            String [] storeE = new String[5];
            for (int i = 0; i < 5; i++) {
              input = inputStream.nextLine();
              splittedSen = input.split(delimeters);
              splittedSen[1] = splittedSen[1].replaceAll("\"","").trim();
              storeE[i] = splittedSen[1];
            }
            int inputID = Integer.parseInt(storeE[0]);
            Float inputPrice =  Float.parseFloat(storeE[2]);
            try {
              Electronics e = new Electronics( inputID, storeE[1], inputPrice,
                storeE[3], storeE[4]);
              temp.add(e);
            } catch (Exception e) {
              //handle exception
              System.out.println(e.getMessage());
            }
          } 
        }
      }
    }
    inputStream.close();
    return temp;
  }

  /**
   * This method prints the existing productList into the current (input) file, 
   * overwriting it with the new attributes of the updated productList.
   * @param pList is Product ArrayList
   * @param fileName is the name of the file that will be printed into.
   * @return int: 1 if the items have been printed, else 0.
   */
  public int printIntoFile( ArrayList<Product> pList, String fileName) {
    PrintWriter outputStream = null;
    int works = 0;
    try {
        outputStream = new PrintWriter(new FileOutputStream(fileName));
    } catch (FileNotFoundException e) {
        System.out.println("Error opening the file \""+fileName+"\"");
        System.exit(0);
    }

    for (Product p : pList) {
      outputStream.println(p.printToFile());
      works = 1;
    }
    outputStream.close();
    return works;
  }

  /**
   * This method creates the HashMap that will store Key-Value pairs of a description key
   * and its corresponding ArrayList{@literal <}Integer{@literal >} values, indicating the indices that the given 
   * description is found within the productList.
   * @param pList is Product ArrayList
   * @return HashMap: creates the HashMap that maps indices of productList to its corresponding String key.
   */
  public HashMap<String, ArrayList<Integer>> createHashDesc( ArrayList<Product> pList) {
    HashMap<String, ArrayList<Integer>> hashDesc = new HashMap<String, ArrayList<Integer>>(); //hashMap for search
    for (Product p : pList) { //loop through each product
      String [] splitDesc = p.getDesc().split("[^a-zA-Z0-9.]"); //split product description
      for (int k = 0; k < splitDesc.length; k++) { //loop through length of product description, each keyword 
        if (!hashDesc.containsKey(splitDesc[k])) { //check if Key is already created, if not, create new Value list
          ArrayList<Integer> hashIndex = new ArrayList<Integer>();
          for (int j = 0; j < pList.size(); j++) { //loop through products again to check what to add
            String pDesc = pList.get(j).getDesc().replaceAll("\\s"," ").trim(); //remove extra white space from current product description
            String [] pDescArr = pDesc.split("[^a-zA-Z0-9.]"); //split current description into array
            for (int x = 0; x < pDescArr.length; x++) { //loop through description words and check with keyword, if present, add index.
              if (pDescArr[x].equalsIgnoreCase(splitDesc[k])) {
                hashIndex.add(j);
              }
            }
          }
          hashDesc.put( splitDesc[k], hashIndex); //add this arrayList to hashMap.
        }
      }
    }

    // System.out.println(""+hashDesc);
    return hashDesc;
  }
    
}