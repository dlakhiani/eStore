/*
 * This Java source file was generated by the Gradle 'init' task.
 * Contains the main() for the program.
 * @author Dhruv Lakhiani
 */
package eStoreSearch;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.Set;
import java.util.Iterator;

import java.awt.*;
import javax.swing.*;
import java.awt.event.*;

public class Gui extends JFrame {
  private static final long serialVersionUID = 1L;
  public static final int WIDTH = 550;
  public static final int HEIGHT = 350;
  public static final int LOCATEX = 200;
  public static final int LOCATEY = 100;
  public static final int START_YEAR = 1000;
  public static final int END_YEAR = 9999;

  EStoreSearch methods = new EStoreSearch();

  protected ArrayList<Product> pList;
  protected HashMap<String, ArrayList<Integer>> hashDesc;
  String fileName;
  int switchBox=0; //on Book Panel initially

  public static final String [] FIELD_STRINGS = { 
    "*Product ID", "*Description", "Price", "*Year", 
    "Authors", "Publisher", "Maker"};

  public static final String[] KEY_STRINGS = { "Product ID", "Description Keywords", "Start Year", "End Year" };

  private JComboBox<String> typeComboBox;
  private JPanel holderPanel;
  private JPanel initPanel;
  private JPanel addPanel;
  private JPanel searchPanel;
  private JPanel fieldPanel;

  JTextField[] bookFields;
  JTextField[] electronicsFields;
  JTextField[] searchFields;
  JTextArea searchPrintTextArea;
  JTextArea printTextArea;

  //Event Methods
  /**
   * Listener for Menu Item "Add"
   */
  private class addListener implements ActionListener {
    public void actionPerformed(ActionEvent e) {
      addPanel.setVisible(true);
    
      searchPanel.setVisible(false);
      initPanel.setVisible(false);
    }
  }

  /**
   * Listener for Menu Item "Search"
   */
  private class searchListener implements ActionListener {
      public void actionPerformed(ActionEvent e) {
        searchPanel.setVisible(true);

        addPanel.setVisible(false);
        initPanel.setVisible(false);
      }
  }

  /**
   * Listener for Menu Item "Quit"
   */
  private class quitListener implements ActionListener {
    public void actionPerformed(ActionEvent e) {
      methods.printIntoFile(pList, fileName);
      System.exit(0);
    }
  }

  /**
   * Listener for ComboBoxItem: Book or Electronics
   */
  private class typeListener implements ActionListener {
    public void actionPerformed(ActionEvent e) {
      JComboBox cb = (JComboBox)e.getSource();
      String product = (String)cb.getSelectedItem();
      if (product.equals("Book")) {
        switchBox=0;
      } else if (product.equals("Electronics")) {
        switchBox=1;
      }
      CardLayout c = (CardLayout)fieldPanel.getLayout();
      c.next(fieldPanel);
    }
  }

  /**
   * Listener for Buttons: Reset, Add, Search
   */
  private class doneListener implements ActionListener {
    public void actionPerformed(ActionEvent e) {
      String buttonString = e.getActionCommand();

      if (buttonString.equals("Reset")) {
        resetFields(bookFields);
        resetFields(electronicsFields);
        resetSearchFields(searchFields);
        printTextArea.setEditable(true);
        printTextArea.setText("");
        printTextArea.setEditable(false);
        searchPrintTextArea.setEditable(true);
        searchPrintTextArea.setText("");
        searchPrintTextArea.setEditable(false);
      } else if (buttonString.equals("Add")) {
        if (switchBox==0) {
          addBook();
          resetFields(bookFields);
        } else if (switchBox==1) {
          addElectronics();
          resetFields(electronicsFields);
        }
      } else if (buttonString.equals("Search")) {
        searchProducts();
        resetSearchFields(searchFields);
      }
    }
  }

  /**
   * Listener for TextFields, will clear pre-filled text once user clicks it
   */
  public class vanishingText implements FocusListener {
    public void focusGained(FocusEvent e) {
      JTextField source = (JTextField) e.getComponent();
      source.setText("");
    }

    public void focusLost(FocusEvent e) {
      // nothing
    }
  }

  public static void main(String[] args) {
    Gui gui = new Gui();
    EStoreSearch myStore = new EStoreSearch();

    if (args.length != 0) { //Read File Input
      gui.fileName = args[0];
      myStore.p = myStore.fileRead(gui.fileName);
    } else {
      gui.fileName = "outputTest.txt";
    }
    myStore.hash = myStore.createHashDesc(myStore.p);

    gui.pList = myStore.p; //stores arrayList<product>
    gui.hashDesc = myStore.hash; //stores hashDesc
    gui.setVisible(true);
  }

  //Gui Methods
  /**
   * To prepare the GUI for the Add section of the program
   * @param addPanel
   */
  public void addContent(JPanel addPanel) {
    //holder panel for Book & Electronics
    fieldPanel = new JPanel();
    fieldPanel.setLayout(new CardLayout());

    //objects shared by both panels
    String[] productTypeString = { "Book", "Electronics" };
    typeComboBox = new JComboBox<>(productTypeString);
    typeComboBox.setSelectedIndex(0);
    typeComboBox.addActionListener(new typeListener());

    int rows = 0, cols = 0;
    //add objects to bookPanel
    JLabel title = new JLabel("Adding a book (* - Required Field)");
    title.setOpaque(true);
    JPanel bookPanel = new JPanel();
    rows = 7; cols = 1;
    bookPanel.setLayout(new GridLayout(rows, cols));
    bookPanel.add(title);
    bookFields = new JTextField[FIELD_STRINGS.length - 1];
    for (int i = 0; i < bookFields.length; i++) {
      bookFields[i] = new JTextField(FIELD_STRINGS[i]);
      bookFields[i].addFocusListener(new vanishingText());
      bookPanel.add(bookFields[i]);
    }
    bookPanel.setVisible(true);
    fieldPanel.add(bookPanel);

    //add objects to electronicsPanel
    JLabel titleV2 = new JLabel("Adding an electronic  (* - Required Field)");
    titleV2.setOpaque(true);
    JPanel electronicsPanel = new JPanel();
    rows = 6; cols = 1;
    electronicsPanel.setLayout(new GridLayout(rows, cols));
    electronicsPanel.add(titleV2);
    electronicsFields = new JTextField[FIELD_STRINGS.length - 2];
    for (int i = 0; i < electronicsFields.length-1; i++) {
      electronicsFields[i] = new JTextField(FIELD_STRINGS[i]);
      electronicsFields[i].addFocusListener(new vanishingText());
      electronicsPanel.add(electronicsFields[i]);
    }
    electronicsFields[4] = new JTextField(FIELD_STRINGS[6]);
    electronicsFields[4].addFocusListener(new vanishingText());
    electronicsPanel.add(electronicsFields[4]);
    electronicsPanel.setVisible(true);
    fieldPanel.add(electronicsPanel);

    // create holder panel for Fields & JButtons
    JPanel addHolder = new JPanel();
    addHolder.setLayout(new BoxLayout(addHolder, BoxLayout.X_AXIS));

    //panel for buttons
    JPanel buttonPanel = new JPanel();
    buttonPanel.setLayout(new BoxLayout(buttonPanel, BoxLayout.Y_AXIS));
    JButton resetButton = new JButton("Reset");
    resetButton.addActionListener(new doneListener());
    buttonPanel.add(resetButton);
    JButton addButton = new JButton("Add");
    addButton.addActionListener(new doneListener());
    buttonPanel.add(addButton);

    //add objects to addHolder
    addHolder.add(fieldPanel);
    addHolder.add(buttonPanel);
    
    // print messages for scrollPane
    JPanel messagePanel = new JPanel();
    messagePanel.setLayout(new BorderLayout());
    JLabel msgTitle = new JLabel("Messages");
    msgTitle.setOpaque(true);
    printTextArea = new JTextArea();
    printTextArea.setOpaque(true);
    printTextArea.setBackground(Color.WHITE);
    JScrollPane scrolledText = new JScrollPane(printTextArea);
    scrolledText.setHorizontalScrollBarPolicy(JScrollPane.HORIZONTAL_SCROLLBAR_AS_NEEDED);
    scrolledText.setVerticalScrollBarPolicy(JScrollPane.VERTICAL_SCROLLBAR_ALWAYS);
    scrolledText.setPreferredSize(new Dimension(100, 100));
    printTextArea.setEditable(false);
    messagePanel.add(msgTitle, BorderLayout.NORTH);
    messagePanel.add(scrolledText, BorderLayout.CENTER);

    //add addHolder
    addPanel.setLayout(new BoxLayout(addPanel, BoxLayout.Y_AXIS));
    addPanel.add(typeComboBox);
    addPanel.add(addHolder);
    addPanel.add(messagePanel);

    return;
  }

  /**
   * To prepare the GUI for the Search section of the program
   * @param searchPanel
   */
  public void searchContent(JPanel searchPanel) {
    // holder panel 
    int rows = 0, cols = 0;
    // add objects to keyPanel
    JLabel title = new JLabel("Searching products");
    title.setOpaque(true);
    JPanel keyPanel = new JPanel();
    rows = 5;
    cols = 1;
    keyPanel.setLayout(new GridLayout(rows, cols));
    keyPanel.add(title);
    searchFields = new JTextField[4];
    for (int i = 0; i < searchFields.length; i++) {
      searchFields[i] = new JTextField(KEY_STRINGS[i]);
      searchFields[i].addFocusListener(new vanishingText());
      keyPanel.add(searchFields[i]);
    }
    keyPanel.setVisible(true);

    // create holder panel for Fields & JButtons
    JPanel searchHolder = new JPanel();
    searchHolder.setLayout(new BoxLayout(searchHolder, BoxLayout.X_AXIS));

    // panel for buttons
    JPanel buttonPanel = new JPanel();
    buttonPanel.setLayout(new BoxLayout(buttonPanel, BoxLayout.Y_AXIS));
    JButton resetButton = new JButton("Reset");
    resetButton.addActionListener(new doneListener());
    buttonPanel.add(resetButton);
    JButton addButton = new JButton("Search");
    addButton.addActionListener(new doneListener());
    buttonPanel.add(addButton);

    // add objects to searchHolder
    searchHolder.add(keyPanel);
    searchHolder.add(buttonPanel);

    // print messages for scrollPane
    JPanel messagePanel = new JPanel();
    messagePanel.setLayout(new BorderLayout());
    JLabel msgTitle = new JLabel("Search Result");
    title.setOpaque(true);

    searchPrintTextArea = new JTextArea();
    searchPrintTextArea.setOpaque(true);
    searchPrintTextArea.setBackground(Color.WHITE);
    JScrollPane scrolledText = new JScrollPane(searchPrintTextArea);
    scrolledText.setHorizontalScrollBarPolicy(JScrollPane.HORIZONTAL_SCROLLBAR_AS_NEEDED);
    scrolledText.setVerticalScrollBarPolicy(JScrollPane.VERTICAL_SCROLLBAR_ALWAYS);
    scrolledText.setPreferredSize(new Dimension(100, 100));
    searchPrintTextArea.setEditable(false);
    messagePanel.add(msgTitle, BorderLayout.NORTH);
    messagePanel.add(scrolledText, BorderLayout.CENTER);

    // add searchHolder
    searchPanel.setLayout(new BoxLayout(searchPanel, BoxLayout.Y_AXIS));
    searchPanel.add(searchHolder);
    searchPanel.add(messagePanel);

    return;
  }

  /**
   * To prepare the GUI for the Home/Initial section of the program
   * @param initPanel
   */
  public void addInitialContent(JPanel initPanel) {
    int rows = 1, cols = 1;
    initPanel.setLayout(new GridLayout(rows, cols));

    String msg = "\t\tWelcome to eStoreSearch\n \n\t\tChoose a command from the \"Commands\" menu above for \n"+
                 "\t\tadding a product, searching products, or quitting the program.";
    JLabel initLabel = new JLabel("<html>"+msg.replaceAll("\n", "<br/>").replaceAll("\t", "&emsp;")+"</html>");
    initLabel.setFont(initLabel.getFont().deriveFont(Font.ITALIC));
    initLabel.addFocusListener(new vanishingText());
    initPanel.add(initLabel);

    return;
  }

  /**
   * To present messages in the TextArea for the Add section
   * @param message
   */
  public void exceptionDialog(String message) {
    printTextArea.setEditable(true);
    printTextArea.append(message+"\n***\n");
    printTextArea.setEditable(false);
  }

  /**
   * To present messages in the TextArea for the Search section
   * @param message
   */
  public void exceptionDialogSearch(String message) {
    searchPrintTextArea.setEditable(true);
    searchPrintTextArea.append(message + "\n***\n");
    searchPrintTextArea.setEditable(false);
  }

  //Functional Methods
  /**
   * To reset TextFields for the Add section
   * @param clearFields
   */
  public void resetFields(JTextField[] clearFields) {
    for (int i = 0; i < clearFields.length; i++) {
      clearFields[i].setText(FIELD_STRINGS[i]);
    }
  }

  /**
   * To reset TextFields for the Search section
   */
  public void resetSearchFields(JTextField[] clearFields) {
    for (int i = 0; i < clearFields.length; i++) {
      clearFields[i].setText(KEY_STRINGS[i]);
    }
  }

  /**
   * To check if String entered is empty
   * @param storeSentence
   * @return true if empty, else false.
   */
  public boolean isEmptyString(String storeSentence) {
    if (storeSentence == null || storeSentence.length() == 0 || storeSentence.trim().isEmpty()
        || storeSentence.equals("[\\s]")) {
      return true;
    } else {
      return false;
    }
  }

  /**
   * To retrieve input to create a Book Object
   */
  public void addBook() { 
    try {
      Book b = new Book();
      String [] text = new String[bookFields.length];
      for (int i = 0; i < bookFields.length; i++) {
        text[i] = bookFields[i].getText();
      }

      //checking textFields
      for (int i = 0; i < 2; i++) { //checks product ID & description
        if (isEmptyString(text[i]) == true || text[i].equals(FIELD_STRINGS[i])) {
          exceptionDialog("Please fill in: Product ID, Description, Year.");
          resetFields(bookFields);
          return;
        }
      }
      if (isEmptyString(text[3]) == true || text[3].equals(FIELD_STRINGS[3])) { //checks year
        exceptionDialog("Please fill in: Product ID, Description, Year.");
        resetFields(bookFields);
        return;
      }

      //adding productID
      try {
        int intParser = Integer.parseInt(text[0]);
        if (methods.isOfLength(6, text[0]) == false) {
          exceptionDialog("Error: the productID must be 6 digits.");
          return;
        } else if (methods.compareID(pList, intParser) == true) {
          exceptionDialog("Error: the productID is not available as it already exists.");
          return;
        } else {
          try {
            b.setProductID(intParser);
          } catch (Exception e) {
            exceptionDialog("Error: the productID must be between 0 and 999999.");
            return;
          }
        }
      } catch (Exception e) {
        exceptionDialog("Error: the productID cannot be a String.");
      }

      //adding description
      b.setDesc(text[1]);

      //adding year
      try {
        b.setYear(text[3]);
      } catch (Exception e) {
        exceptionDialog("Error: the year must be between 1000 and 9999.");
        return;
      }

      //adding other: price, author, publishers
      if (isEmptyString(text[2]) == true || text[2].equals(FIELD_STRINGS[2])) {
        b.setPrice(0.0f);
      } else {
        float fParser = 0.0f; 
        try {
          fParser = Float.parseFloat(text[2]);
        } catch (Exception e) {
          exceptionDialog("Price cannot be a String.");
          return;
        }
        b.setPrice(fParser);
      }

      if (isEmptyString(text[4]) == true || text[4].equals(FIELD_STRINGS[4])) {
        text[4]="";
      } 
      b.setAuthors(text[4]);

      if (isEmptyString(text[5]) == true || text[5].equals(FIELD_STRINGS[5])) {
        text[5] = "";
      }
      b.setPublisher(text[5]);
      methods.addProduct(pList, b);
      exceptionDialog("Book added successfully.");
    } catch (Exception e) {
      exceptionDialog("Fatal Error: Book object failed");
      return;
    }
  }

  /**
   * To retrieve input to create an Electronics Object
   */  
  public void addElectronics() {
    try {
      Electronics elec = new Electronics();
      String[] text = new String[electronicsFields.length];
      for (int i = 0; i < electronicsFields.length; i++) {
        text[i] = electronicsFields[i].getText();
      }

      // checking textFields
      for (int i = 0; i < 2; i++) { // checks product ID & description
        if (isEmptyString(text[i]) == true || text[i].equals(FIELD_STRINGS[i])) {
          exceptionDialog("Please fill in: Product ID, Description, Year.");
          resetFields(electronicsFields);
          return;
        }
      }
      if (isEmptyString(text[3]) == true || text[3].equals(FIELD_STRINGS[3])) { // checks year
        exceptionDialog("Please fill in: Product ID, Description, Year.");
        resetFields(electronicsFields);
        return;
      }

      // adding productID
      try {
        int intParser = Integer.parseInt(text[0]);
        if (methods.isOfLength(6, text[0]) == false) {
          exceptionDialog("Error: the productID must be 6 digits.");
          return;
        } else if (methods.compareID(pList, intParser) == true) {
          exceptionDialog("Error: the productID is not available as it already exists.");
          return;
        } else {
          try {
            elec.setProductID(intParser);
          } catch (Exception e) {
            exceptionDialog("Error: the productID must be between 0 and 999999.");
            return;
          }
        }
      } catch (Exception e) {
        exceptionDialog("Error: the productID cannot be a String.");
      }

      // adding description
      elec.setDesc(text[1]);

      // adding year
      try {
        elec.setYear(text[3]);
      } catch (Exception e) {
        exceptionDialog("Error: the year must be between 1000 and 9999.");
        return;
      }

      // adding other: price, maker
      if (isEmptyString(text[2]) == true || text[2].equals(FIELD_STRINGS[2])) {
        elec.setPrice(0.0f);
      } else {
        float fParser = 0.0f;
        try {
          fParser = Float.parseFloat(text[2]);
        } catch (Exception e) {
          exceptionDialog("Price cannot be a String.");
          return;
        }
        elec.setPrice(fParser);
      }

      if (isEmptyString(text[4]) == true || text[4].equals(FIELD_STRINGS[4])) {
        text[4] = "";
      }
      elec.setMaker(text[4]);

      methods.addProduct(pList, elec);
      exceptionDialog("Electronic added successfully.");
    } catch (Exception e) {
      exceptionDialog("Fatal Error: Electronics object failed.");
      return;
    }
  }

  /**
   * To retrieve input for the Search methods
   */
  public void searchProducts() {
    boolean isEmptyID = false, isEmptyDesc = false, isEmptyTime = true;
    int id = 0, start = START_YEAR, end = END_YEAR; //starting time period and ending time period
    String desc = "";

    if (pList.size() == 0) {
      exceptionDialogSearch("There are currently no products in the store.");
    } else {
      String[] text = new String[searchFields.length];
      for (int i = 0; i < searchFields.length; i++) {
        text[i] = searchFields[i].getText();
      }

      // checking productID
      if (isEmptyString(text[0]) == true || text[0].equals(KEY_STRINGS[0])) {
        isEmptyID=true;
      } else {
        try {
          int intParser = Integer.parseInt(text[0]);
          if (methods.isOfLength(6, text[0]) == false) {
            exceptionDialogSearch("Error: the productID must be 6 digits.");
            return;
          } else {
            id = intParser;
          }
        } catch (Exception e) {
          exceptionDialogSearch("Error: the productID cannot be a String");
          return;
        }
      }
      //checking description
      if (isEmptyString(text[1]) == true || text[1].equals(KEY_STRINGS[1])) {
        isEmptyDesc = true;
      } else {
        desc = text[1];
      }
      //checking years
      if (isEmptyString(text[2]) == true && text[2].equals(KEY_STRINGS[2]) 
          && (isEmptyString(text[3]) != true && !text[3].equals(KEY_STRINGS[3]))) { //start period is not given
        isEmptyTime = true;
        try {
          end = Integer.parseInt(text[3]);
        } catch (Exception e) {
          exceptionDialogSearch("Error: the end Year cannot have String.");
          return;
        }
      } 
      if (isEmptyString(text[3]) == true && text[3].equals(KEY_STRINGS[3]) 
          && (isEmptyString(text[2]) != true && !text[2].equals(KEY_STRINGS[2]))) { //end period is not given
        isEmptyTime = true;
        try {
          start = Integer.parseInt(text[2]);
        } catch (Exception e) {
          exceptionDialogSearch("Error: the start Year cannot have String.");
          return;
        }
      }
      if (isEmptyString(text[2]) != true && !text[2].equals(KEY_STRINGS[2]) ||
          isEmptyString(text[3]) != true && !text[3].equals(KEY_STRINGS[3])) { //both years are present
        isEmptyTime = false;
        try {
          start = Integer.parseInt(text[2]);
          end = Integer.parseInt(text[3]);
        } catch (Exception e) {
          exceptionDialogSearch("Error: the Years cannot have String.");
          return;
        }
      }
      if ( (start < START_YEAR || start > END_YEAR) || 
          (end < START_YEAR || end > END_YEAR) ) { //check the interval
        exceptionDialogSearch("Error: the time period must be between 1000 and 9999.");        
        return;
      }
      
      hashDesc = methods.createHashDesc(pList);

      // print according to fields
      if (isEmptyID == false && (isEmptyDesc == true && isEmptyTime == true)) { // only productID
        searchID(pList, id);
      }
      if (isEmptyDesc == false && (isEmptyID == true && isEmptyTime == true)) { // only description
        searchDesc(pList, desc, hashDesc);
      }
      if (isEmptyTime == false && (isEmptyID == true && isEmptyDesc == true)) { // only timePeriod
        searchTime(pList, start, end);
      }
      if (isEmptyID == true && (isEmptyDesc == false && isEmptyTime == false)) { // no productID
        searchDescAndTime(pList, desc, start, end, hashDesc);
      }
      if (isEmptyDesc == true && (isEmptyID == false && isEmptyTime == false)) { // no description
        searchIDAndTime(pList, id, start, end);
      }
      if (isEmptyTime == true && (isEmptyID == false && isEmptyDesc == false)) { // no timePeriod
        searchIDAndDesc(pList, id, desc, hashDesc);
      }
      if ((isEmptyID == false) && (isEmptyDesc == false) && (isEmptyTime == false)) { // print specific items
        searchSpecific(pList, id, desc, start, end, hashDesc);
      }
      if ((isEmptyID == true) && (isEmptyDesc == true) && (isEmptyTime == true)) { // print all items
        printAllItems(pList);
      }
    }
  }

  /**
   * This method prints Product ArrayList.
   * @param pList is Product ArrayList
   * @return int: 1 if items have been printed, else 0.
   */
  public int printAllItems(ArrayList<Product> pList) {
    int works = 0;
    for (Product p : pList) {
      exceptionDialogSearch(p.toString());
      works = 1;
    }
    return works;
  }

  /**
   * This method searches for the Products containing the productID given, and
   * prints the ones that have it.
   * @param pList is Product ArrayList
   * @param id    is the productID (int) given.
   * @return int: 1 if items have been printed, else 0.
   */
  public int searchID(ArrayList<Product> pList, int id) {
    int works = 0;
    for (int i = 0; i < pList.size(); i++) {
      if (id == pList.get(i).getProductID()) {
        exceptionDialogSearch(pList.get(i).toString());
        works = 1;
      }
    }

    if (works != 1) {
      exceptionDialogSearch("There is no product with the given productID: " + id);
    } else {
      works = 1;
    }
    return works;
  }

  /**
   * This method searches for the Products containing the description given, and
   * prints the Products that have it.
   * @param pList    is Product ArrayList
   * @param desc     is the description (String) given.
   * @param hashDesc is the hashMap for the existing descriptions.
   * @return int: 1 if items have been printed, else 0.
   */
  public int searchDesc(ArrayList<Product> pList, String desc, HashMap<String, ArrayList<Integer>> hashDesc) {
    int works = 0;
    // split keyword description
    ArrayList<Integer> intersection = new ArrayList<Integer>(); // final arrayList for description
    for (int i = 0; i < pList.size(); i++) { // pre-fill arrayList with indices of pList
      intersection.add(i);
    }

    Set<HashMap.Entry<String, ArrayList<Integer>>> entries = hashDesc.entrySet();
    Iterator<HashMap.Entry<String, ArrayList<Integer>>> iter = entries.iterator(); // used to move through hashMap
    desc = desc.replaceAll("\\s", " ").trim(); // remove extra white space from userKeyword
    String[] splittedDesc = desc.split("[^a-zA-Z0-9.]"); // split keywords into array
    for (int i = 0; i < splittedDesc.length; i++) { // loop hashMap through the keywords provided
      iter = entries.iterator();
      while (iter.hasNext()) {
        HashMap.Entry<String, ArrayList<Integer>> entry = iter.next();
        if (splittedDesc[i].equalsIgnoreCase(entry.getKey())) { // has key? store indices!
          intersection.retainAll(entry.getValue());
        }
      }
    }

    for (int i = 0; i < intersection.size(); i++) {
      exceptionDialogSearch(""+pList.get(intersection.get(i)));
      works = 1;
    }

    if (works != 1) {
      exceptionDialogSearch("\nThere is no product with the given description: " + desc);
    } else {
      works = 1;
    }
    return works;
  }

  /**
   * This method searches for the Products containing the time period given, and
   * prints the Products that have it.
   * @param pList is Product ArrayList
   * @param start is the beginning year (int).
   * @param end   is the ending year (int).
   * @return int: 1 if items have been printed, else 0.
   */
  public int searchTime(ArrayList<Product> pList, int start, int end) {
    int works = 0;
    for (int i = 0; i < pList.size(); i++) {
      int pYear = Integer.parseInt(pList.get(i).getYear());
      if ((pYear >= start) && (pYear <= end)) {
        exceptionDialogSearch(pList.get(i).toString());
        works = 1;
      }
    }
    if (works != 1) {
      exceptionDialogSearch("There is no product within the given time period: " + start + " - " + end);
    } else {
      works = 1;
    }
    return works;
  }

  /**
   * This method searches for the Products containing the time period and the
   * description given, and prints the Products that have it.
   * @param pList    is Product ArrayList
   * @param desc     is the description given (String).
   * @param start    is the beginning year (int).
   * @param end      is the ending year (int).
   * @param hashDesc is the hashMap for the existing descriptions.
   * @return int: 1 if items have been printed, else 0.
   */
  public int searchDescAndTime(ArrayList<Product> pList, String desc, int start, int end,
      HashMap<String, ArrayList<Integer>> hashDesc) {
    int works = 0;
    // split keyword description
    ArrayList<Integer> intersection = new ArrayList<Integer>(); // final arrayList for description
    for (int i = 0; i < pList.size(); i++) { // pre-fill arrayList with indices of pList
      intersection.add(i);
    }

    Set<HashMap.Entry<String, ArrayList<Integer>>> entries = hashDesc.entrySet();
    Iterator<HashMap.Entry<String, ArrayList<Integer>>> iter = entries.iterator(); // used to move through hashMap
    desc = desc.replaceAll("\\s", " ").trim(); // remove extra white space from userKeyword
    String[] splittedDesc = desc.split("[^a-zA-Z0-9.]"); // split keywords into array
    for (int i = 0; i < splittedDesc.length; i++) { // loop hashMap through the keywords provided
      iter = entries.iterator();
      while (iter.hasNext()) {
        HashMap.Entry<String, ArrayList<Integer>> entry = iter.next();
        if (splittedDesc[i].equalsIgnoreCase(entry.getKey())) { // has key? sotre indices!
          intersection.retainAll(entry.getValue());
        }
      }
    }

    for (int i = 0; i < intersection.size(); i++) {
      int pYear = Integer.parseInt(pList.get(intersection.get(i)).getYear());
      if ((pYear >= start) && (pYear <= end)) {
        exceptionDialogSearch("" + pList.get(intersection.get(i)));
        works = 1;
      }
    }

    if (works != 1) {
      exceptionDialogSearch(
          "There is no product with the given description: " + desc + " and time period: " + start + " - " + end);
    } else {
      works = 1;
    }
    return works;
  }

  /**
   * This method searches for the Products containing the time period and the
   * productID given, and prints the Products that have it.
   * @param pList is Product ArrayList
   * @param id    is the productID (int) given.
   * @param start is the beginning year (int).
   * @param end   is the ending year (int).
   * @return int: 1 if items have been printed, else 0.
   */
  public int searchIDAndTime(ArrayList<Product> pList, int id, int start, int end) {
    int works = 0;
    for (int i = 0; i < pList.size(); i++) {
      int pYear = Integer.parseInt(pList.get(i).getYear());
      if ((pYear >= start) && (pYear <= end)) {
        if (id == pList.get(i).getProductID()) {
          exceptionDialogSearch(pList.get(i).toString());
          works = 1;
        }
      }
    }
    if (works != 1) {
      System.out
          .println("There is no product with the given productID: " + id + " and time period: " + start + " - " + end);
    } else {
      works = 1;
    }
    return works;
  }

  /**
   * This method searches for the Products containing the productID and the
   * description given, and prints the Products that have it.
   * @param pList    is Product ArrayList
   * @param id       is the productID (int) given.
   * @param desc     is the description (String) given.
   * @param hashDesc is the hashMap for the existing descriptions.
   * @return int: 1 if items have been printed, else 0.
   */
  public int searchIDAndDesc(ArrayList<Product> pList, int id, String desc,
      HashMap<String, ArrayList<Integer>> hashDesc) {
    int works = 0;
    // split keyword description
    ArrayList<Integer> intersection = new ArrayList<Integer>(); // final arrayList for description
    for (int i = 0; i < pList.size(); i++) { // pre-fill arrayList with indices of pList
      intersection.add(i);
    }

    Set<HashMap.Entry<String, ArrayList<Integer>>> entries = hashDesc.entrySet();
    Iterator<HashMap.Entry<String, ArrayList<Integer>>> iter = entries.iterator(); // used to move through hashMap
    desc = desc.replaceAll("\\s", " ").trim(); // remove extra white space from userKeyword
    String[] splittedDesc = desc.split("[^a-zA-Z0-9.]"); // split keywords into array
    for (int i = 0; i < splittedDesc.length; i++) { // loop hashMap through the keywords provided
      iter = entries.iterator();
      while (iter.hasNext()) {
        HashMap.Entry<String, ArrayList<Integer>> entry = iter.next();
        if (splittedDesc[i].equalsIgnoreCase(entry.getKey())) { // has key? sotre indices!
          intersection.retainAll(entry.getValue());
        }
      }
    }

    for (int i = 0; i < intersection.size(); i++) {
      if (id == pList.get(intersection.get(i)).getProductID()) {
        exceptionDialogSearch("" + pList.get(intersection.get(i)));
        works = 1;
      }
    }

    if (works != 1) {
      String formatID = String.format("%06d", id);
      exceptionDialogSearch("There is no product with the given description: " + desc + " and productID: " + formatID);
    } else {
      works = 1;
    }
    return works;
  }

  /**
   * This method searches for the Products containing the productID, time period,
   * and the description given, and prints the Products that have it.
   * @param pList    is Product ArrayList
   * @param id       is the productID (int) given.
   * @param start    is the beginning year (int).
   * @param end      is the ending year (int).
   * @param desc     is the description given (String).
   * @param hashDesc is the hashMap for the existing descriptions.
   * @return int: 1 if items have been printed, else 0.
   */
  public int searchSpecific(ArrayList<Product> pList, int id, String desc, int start, int end,
      HashMap<String, ArrayList<Integer>> hashDesc) {
    int works = 0;
    // split keyword description
    ArrayList<Integer> intersection = new ArrayList<Integer>(); // final arrayList for description
    for (int i = 0; i < pList.size(); i++) { // pre-fill arrayList with indices of pList
      intersection.add(i);
    }

    Set<HashMap.Entry<String, ArrayList<Integer>>> entries = hashDesc.entrySet();
    Iterator<HashMap.Entry<String, ArrayList<Integer>>> iter = entries.iterator(); // used to move through hashMap
    desc = desc.replaceAll("\\s", " ").trim(); // remove extra white space from userKeyword
    String[] splittedDesc = desc.split("[^a-zA-Z0-9.]"); // split keywords into array
    for (int i = 0; i < splittedDesc.length; i++) { // loop hashMap through the keywords provided
      iter = entries.iterator();
      while (iter.hasNext()) {
        HashMap.Entry<String, ArrayList<Integer>> entry = iter.next();
        if (splittedDesc[i].equalsIgnoreCase(entry.getKey())) { // has key? sotre indices!
          intersection.retainAll(entry.getValue());
        }
      }
    }

    for (int i = 0; i < intersection.size(); i++) {
      int pYear = Integer.parseInt(pList.get(intersection.get(i)).getYear());
      if ((pYear >= start) && (pYear <= end)) {
        if (id == pList.get(intersection.get(i)).getProductID()) {
          exceptionDialogSearch("" + pList.get(intersection.get(i)));
          works = 1;
        }
      }
    }

    if (works != 1) {
      exceptionDialogSearch("There is no product of productID: " + id + ", with the given description: " + desc
          + ", and time period: " + start + " - " + end);
    } else {
      works = 1;
    }
    return works;
  }

  /**
   * Prepare JFrame
   */
  public Gui() {    
    super("eStoreSearch");
    setSize(WIDTH, HEIGHT);
    setResizable(false);
    setLocation(200, 100);
    setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
    setLayout(new BorderLayout()); 

    //panel creations: holds center for panels
    holderPanel = new JPanel();
    holderPanel.setVisible(true);
    holderPanel.setLayout(new BoxLayout(holderPanel, BoxLayout.Y_AXIS));

    initPanel = new JPanel();
    addInitialContent(initPanel);
    initPanel.setVisible(true);
    holderPanel.add(initPanel);

    addPanel = new JPanel();
    addContent(addPanel); //prepares panel
    addPanel.setVisible(false);
    holderPanel.add(addPanel);

    searchPanel = new JPanel();
    searchContent(searchPanel); //prepares panel
    searchPanel.setVisible(false);
    holderPanel.add(searchPanel);
    
    //prepare student menu
    JMenu commandMenu = new JMenu("Commands");
    JMenuItem add = new JMenuItem("Add");
    add.addActionListener(new addListener());
    commandMenu.add(add);
    JMenuItem search = new JMenuItem("Search");
    search.addActionListener(new searchListener());
    commandMenu.add(search);
    JMenuItem quit = new JMenuItem("Quit");
    quit.addActionListener(new quitListener());
    commandMenu.add(quit);

    //stack above options for menu
    JMenuBar topBar = new JMenuBar();
    topBar.add(commandMenu);

    //present GUI
    add(holderPanel, BorderLayout.CENTER);
    setJMenuBar(topBar);

  }
}